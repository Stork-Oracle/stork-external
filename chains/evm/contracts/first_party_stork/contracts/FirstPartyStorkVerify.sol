// contracts/stork/StorkVerify.sol
// SPDX-License-Identifier: Apache 2

pragma solidity >=0.8.24 <0.9.0;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

contract FirstPartyStorkVerify {
    using ECDSA for bytes32;
    using MessageHashUtils for bytes32;

    function getEthSignedMessageHash32(
        bytes32 message
    ) private pure returns (bytes32) {
        return MessageHashUtils.toEthSignedMessageHash(message);
    }

    function getPublisherMessageHash(
        address pubKey,
        string memory assetPairId,
        uint256 timestamp,
        int256 value
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(pubKey, assetPairId, timestamp, value)
            );
    }

    function getSigner(
        bytes32 signedMessageHash,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) private pure returns (address) {
        bytes memory signature = abi.encodePacked(r, s, v);
        return ECDSA.recover(signedMessageHash, signature);
    }

    function verifyPublisherSignatureV1(
        address publisherPubKey,
        string memory assetPairId,
        uint256 timestamp,
        int256 value,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) public pure returns (bool) {
        bytes32 msgHash = getPublisherMessageHash(
            publisherPubKey,
            assetPairId,
            timestamp / 1_000_000_000,
            value
        );
        bytes32 signedMessageHash = getEthSignedMessageHash32(msgHash);

        // Verify hash was generated by the actual user
        address signer = getSigner(signedMessageHash, r, s, v);
        return signer == publisherPubKey;
    }
}
