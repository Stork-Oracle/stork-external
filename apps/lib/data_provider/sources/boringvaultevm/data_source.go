// Code initially generated by gen.go.
// This file contains the implementation for pulling data from the data source and putting it on the updatesCh.

package boringvaultevm

import (
	"context"
	"embed"
	"fmt"
	"math"
	"math/big"
	"time"

	"github.com/Stork-Oracle/stork-external/apps/lib/data_provider/sources"
	"github.com/Stork-Oracle/stork-external/apps/lib/data_provider/types"
	"github.com/Stork-Oracle/stork-external/apps/lib/data_provider/utils"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/rs/zerolog"
)

const (
	boringVaultEvmAbiFileName         = "boring_vault.json"
	getBoringVaultEvmContractFunction = "getRate"
	getDecimalsContractFunction       = "decimals"
)

//go:embed resources
var resourcesFS embed.FS

type boringVaultEvmDataSource struct {
	logger               zerolog.Logger
	boringVaultEvmConfig BoringVaultEvmConfig
	updateFrequency      time.Duration
	valueId              types.ValueId
	contract             *bind.BoundContract
	decimals             int8
}

func newBoringVaultEvmDataSource(sourceConfig types.DataProviderSourceConfig) *boringVaultEvmDataSource {
	boringVaultEvmConfig, err := GetSourceSpecificConfig(sourceConfig)
	if err != nil {
		panic("unable to decode config: " + err.Error())
	}

	updateFrequency, err := time.ParseDuration(boringVaultEvmConfig.UpdateFrequency)
	if err != nil {
		panic("unable to parse update frequency: " + boringVaultEvmConfig.UpdateFrequency)
	}

	return &boringVaultEvmDataSource{
		boringVaultEvmConfig: boringVaultEvmConfig,
		valueId:              sourceConfig.Id,
		updateFrequency:      updateFrequency,
		logger:               utils.DataSourceLogger(BoringVaultEvmDataSourceId),
	}
}

func (r boringVaultEvmDataSource) RunDataSource(ctx context.Context, updatesCh chan types.DataSourceUpdateMap) {
	updater := func() (types.DataSourceUpdateMap, error) { return r.getUpdate() }
	scheduler := sources.NewScheduler(
		r.updateFrequency,
		updater,
		sources.GetErrorLogHandler(r.logger, zerolog.WarnLevel),
	)
	scheduler.RunScheduler(ctx, updatesCh)
}

func (r boringVaultEvmDataSource) getUpdate() (types.DataSourceUpdateMap, error) {
	if r.contract == nil {
		err := r.initializeBoundContract()
		if err != nil {
			return nil, fmt.Errorf("failed to bind to contract: %v", err)
		}
	}

	updateValue, err := r.getPrice()
	if err != nil {
		return nil, fmt.Errorf("failed to get price: %v", err)
	}

	updates := make(types.DataSourceUpdateMap)

	updateTime := time.Now().UTC().UnixMilli()
	updates[r.valueId] = types.DataSourceValueUpdate{
		Timestamp:    time.UnixMilli(updateTime),
		ValueId:      r.valueId,
		Value:        updateValue,
		DataSourceId: BoringVaultEvmDataSourceId,
	}

	return updates, nil
}

func (r *boringVaultEvmDataSource) initializeBoundContract() error {
	contract, err := sources.GetEthereumContract(
		r.boringVaultEvmConfig.ContractAddress,
		boringVaultEvmAbiFileName,
		r.boringVaultEvmConfig.HttpProviderUrl,
		resourcesFS,
	)
	if err != nil {
		return fmt.Errorf("failed to initialize contract: %v", err)
	}

	decimals, err := sources.CallEthereumFunction(
		contract,
		getDecimalsContractFunction,
		r.valueId,
		r.logger,
	)
	if err != nil {
		return fmt.Errorf("failed to get decimals: %v", err)
	}

	r.decimals = int8(decimals[0].(uint8))
	r.contract = contract

	return nil
}

func (r *boringVaultEvmDataSource) getPrice() (float64, error) {
	result, err := sources.CallEthereumFunction(
		r.contract,
		getBoringVaultEvmContractFunction,
		r.valueId,
		r.logger,
	)
	if err != nil {
		return -1, fmt.Errorf("failed to call ethereum contract: %v", err)
	}

	return calculatePrice(result, r.decimals)
}

func calculatePrice(result []interface{}, decimals int8) (float64, error) {
	price, ok := result[0].(*big.Int)
	if !ok {
		return -1, fmt.Errorf("failed to convert price to big int: %v", ok)
	}

	f := new(big.Float).Quo(
		new(big.Float).SetInt(price),
		new(big.Float).SetFloat64(math.Pow10(int(decimals))),
	)
	val, _ := f.Float64()
	return val, nil
}
