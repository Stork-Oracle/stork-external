// Code initially generated by gen.go.
// This file contains the implementation for pulling data from the data source and putting it on the updatesCh.

package polymarketprovider

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/Stork-Oracle/stork-external/apps/lib/data_provider/sources"
	"github.com/Stork-Oracle/stork-external/apps/lib/data_provider/types"
	"github.com/Stork-Oracle/stork-external/apps/lib/data_provider/utils"
	"github.com/rs/zerolog"
)

type polymarketProviderDataSource struct {
	polymarketProviderConfig PolymarketProviderConfig
	valueId                  types.ValueId
	logger                   zerolog.Logger
	updateFrequency          time.Duration
	httpClient               *http.Client
}

// PolymarketPriceResponse represents the response from Polymarket price API
type PolymarketPriceResponse struct {
	Price string `json:"price"`
	Error string `json:"error,omitempty"`
}

func newPolymarketProviderDataSource(sourceConfig types.DataProviderSourceConfig) *polymarketProviderDataSource {
	polymarketProviderConfig, err := GetSourceSpecificConfig(sourceConfig)
	if err != nil {
		panic("unable to decode config: " + err.Error())
	}

	updateFrequency, err := time.ParseDuration(polymarketProviderConfig.UpdateFrequency)
	if err != nil {
		panic("unable to parse update frequency: " + polymarketProviderConfig.UpdateFrequency)
	}

	return &polymarketProviderDataSource{
		polymarketProviderConfig: polymarketProviderConfig,
		valueId:                  sourceConfig.Id,
		logger:                   utils.DataSourceLogger(PolymarketProviderDataSourceId),
		updateFrequency:          updateFrequency,
		httpClient:               &http.Client{Timeout: 10 * time.Second},
	}
}

func (r polymarketProviderDataSource) RunDataSource(ctx context.Context, updatesCh chan types.DataSourceUpdateMap) {
	updater := func() (types.DataSourceUpdateMap, error) { return r.getUpdate() }
	scheduler := sources.NewScheduler(
		r.updateFrequency,
		updater,
		sources.GetErrorLogHandler(r.logger, zerolog.WarnLevel),
	)
	scheduler.RunScheduler(ctx, updatesCh)
}

func (r polymarketProviderDataSource) getUpdate() (types.DataSourceUpdateMap, error) {
	url := fmt.Sprintf("https://clob.polymarket.com/price?token_id=%s&side=%s", 
		r.polymarketProviderConfig.TokenId, 
		r.polymarketProviderConfig.Side)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	resp, err := r.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make request: %w", err)
	}
	defer resp.Body.Close()

	var priceResp PolymarketPriceResponse
	if err := json.NewDecoder(resp.Body).Decode(&priceResp); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	if priceResp.Error != "" {
		return nil, fmt.Errorf("polymarket API error: %s", priceResp.Error)
	}

	price, err := strconv.ParseFloat(priceResp.Price, 64)
	if err != nil {
		return nil, fmt.Errorf("failed to parse price: %w", err)
	}

	updateMap := types.DataSourceUpdateMap{
		r.valueId: types.DataSourceValueUpdate{
			ValueId:      r.valueId,
			DataSourceId: PolymarketProviderDataSourceId,
			Time:         time.Now(),
			Value:        price,
		},
	}

	return updateMap, nil
}
