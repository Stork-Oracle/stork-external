package fuel

// the header file is generated by cbindgen. If you can't find it, run 'cargo build' in the fuel_ffi directory

/*
#cgo LDFLAGS: -L../../../../../.lib -lfuel_ffi
#cgo CFLAGS: -I../../../../../.lib
#include "fuel_ffi.h"
#include <stdlib.h>
#include <stdint.h>
*/
import "C"
import (
	"encoding/json"
	"fmt"
	"math/big"
	"unsafe"
)

type StorkContract struct {
	Client *C.FuelClient
	Config FuelConfig
}
type FuelConfig struct {
	RpcUrl          string `json:"rpc_url"`
	ContractAddress string `json:"contract_address"`
	PrivateKey      string `json:"private_key"`
}

type FuelTemporalNumericValue struct {
	TimestampNs    uint64   `json:"timestamp_ns"`
	QuantizedValue *big.Int `json:"quantized_value"`
}

type FuelTemporalNumericValueInput struct {
	TemporalNumericValue FuelTemporalNumericValue `json:"temporal_numeric_value"`
	Id                   string                   `json:"id"`
	PublisherMerkleRoot  string                   `json:"publisher_merkle_root"`
	ValueComputeAlgHash  string                   `json:"value_compute_alg_hash"`
	R                    string                   `json:"r"`
	S                    string                   `json:"s"`
	V                    uint8                    `json:"v"`
}

func NewStorkContract(rpcUrl string, contractAddress string, privateKey string) (*StorkContract, error) {
	config := FuelConfig{
		RpcUrl:          rpcUrl,
		ContractAddress: contractAddress,
		PrivateKey:      privateKey,
	}

	configJson, err := json.Marshal(config)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal fuel config: %w", err)
	}

	configCStr := C.CString(string(configJson))
	defer C.free(unsafe.Pointer(configCStr))

	client := C.fuel_client_new(configCStr)
	if client == nil {
		return nil, fmt.Errorf("failed to create fuel client")
	}

	return &StorkContract{
		Client: client,
		Config: config,
	}, nil
}

// Helper function to convert C error codes to Go errors
func (s *StorkContract) handleErrorCode(code C.enum_FuelClientErrorCode) error {
	switch code {
	case C.Success:
		return nil
	case C.InvalidConfig:
		return fmt.Errorf("invalid config")
	case C.ContractCallFailed:
		return fmt.Errorf("contract call failed")
	case C.InsufficientBalance:
		return fmt.Errorf("insufficient balance")
	case C.NetworkError:
		return fmt.Errorf("network error")
	case C.UtxoSpent:
		return fmt.Errorf("UTXO spent")
	case C.InvalidTransaction:
		return fmt.Errorf("invalid transaction")
	case C.JsonError:
		return fmt.Errorf("JSON error")
	case C.SystemError:
		return fmt.Errorf("system error")
	case C.FuelSdkError:
		return fmt.Errorf("Fuel SDK error")
	case C.NullClient:
		return fmt.Errorf("Client is null")
	default:
		return fmt.Errorf("unknown error code: %d", int(code))
	}
}

func (s *StorkContract) UpdateTemporalNumericValuesV1(inputs []FuelTemporalNumericValueInput) (string, error) {
	inputsJson, err := json.Marshal(inputs)
	if err != nil {
		return "", fmt.Errorf("failed to marshal fuel inputs: %w", err)
	}

	inputsCStr := C.CString(string(inputsJson))
	defer C.free(unsafe.Pointer(inputsCStr))

	var outTxHashPtr *C.char
	errorCode := C.fuel_update_values(s.Client, inputsCStr, &outTxHashPtr)

	if err := s.handleErrorCode(errorCode); err != nil {
		return "", fmt.Errorf("fuel_update_values failed: %w", err)
	}

	if outTxHashPtr == nil {
		return "", fmt.Errorf("received null transaction hash")
	}

	txHash := C.GoString(outTxHashPtr)
	C.fuel_free_string(outTxHashPtr)

	return txHash, nil
}

func (s *StorkContract) GetTemporalNumericValueUncheckedV1(id [32]byte) (FuelTemporalNumericValue, error) {
	var result FuelTemporalNumericValue

	// Convert [32]byte to *C.uint8_t
	idPtr := (*C.uint8_t)(unsafe.Pointer(&id[0]))

	var outValueJsonPtr *C.char
	errorCode := C.fuel_get_latest_value(s.Client, idPtr, &outValueJsonPtr)

	if err := s.handleErrorCode(errorCode); err != nil {
		return result, fmt.Errorf("fuel_get_latest_value failed: %w", err)
	}

	if outValueJsonPtr == nil {
		return result, fmt.Errorf("received null value JSON")
	}

	valueJson := C.GoString(outValueJsonPtr)
	C.fuel_free_string(outValueJsonPtr)

	err := json.Unmarshal([]byte(valueJson), &result)
	if err != nil {
		return result, fmt.Errorf("failed to unmarshal value JSON: %w", err)
	}

	return result, nil
}

func (s *StorkContract) GetWalletBalance() (float64, error) {
	var balance C.uint64_t
	errorCode := C.fuel_get_wallet_balance(s.Client, &balance)
	if err := s.handleErrorCode(errorCode); err != nil {
		return 0, fmt.Errorf("fuel_get_wallet_balance failed: %w", err)
	}

	return float64(balance), nil
}

func (s *StorkContract) Close() {
	if s.Client != nil {
		C.fuel_client_free(s.Client)
		s.Client = nil
	}
}
