package bindings

// the header file is generated by cbindgen. If you can't find it, run 'cargo build' in the fuel_ffi directory

/*
#cgo LDFLAGS: -L../../../../../.lib -lfuel_ffi
#cgo CFLAGS: -I../../../../../.lib
#include "fuel_ffi.h"
#include <stdlib.h>
#include <stdint.h>
*/
import "C"

import (
	"encoding/json"
	"errors"
	"fmt"
	"math/big"
	"unsafe"
)

var (
	ErrInvalidConfig                = errors.New("invalid config")
	ErrContractCallFailed           = errors.New("contract call failed")
	ErrNetworkError                 = errors.New("network error")
	ErrInvalidTransactionParameters = errors.New("invalid transaction parameters")
	ErrJSONError                    = errors.New("JSON error")
	ErrSystemError                  = errors.New("system error")
	ErrWalletBalanceError           = errors.New("wallet balance error")
	ErrNullPointer                  = errors.New("null pointer")
	ErrIncorrectFeeAsset            = errors.New("incorrect fee asset")
	ErrInsufficientFee              = errors.New("insufficient fee")
	ErrNoFreshUpdate                = errors.New("no fresh update")
	ErrFeedNotFound                 = errors.New("feed not found")
	ErrInvalidSignature             = errors.New("invalid signature")
	ErrUnknownError                 = errors.New("unknown error")
	ErrNullClientOnCreation         = errors.New("null client on creation")
	ErrNullTransactionHash          = errors.New("null transaction hash")
)

type StorkContract struct {
	Client *C.FuelClient
	Config Config
}

type Config struct {
	RpcUrl          string `json:"rpc_url"`
	ContractAddress string `json:"contract_address"`
	PrivateKey      string `json:"private_key"`
}

type TemporalNumericValue struct {
	TimestampNs    uint64   `json:"timestamp_ns"`
	QuantizedValue *big.Int `json:"quantized_value"`
}

type TemporalNumericValueInput struct {
	TemporalNumericValue TemporalNumericValue `json:"temporal_numeric_value"`
	ID                   string               `json:"id"`
	PublisherMerkleRoot  string               `json:"publisher_merkle_root"`
	ValueComputeAlgHash  string               `json:"value_compute_alg_hash"`
	R                    string               `json:"r"`
	S                    string               `json:"s"`
	V                    uint8                `json:"v"`
}

func NewStorkContract(rpcUrl string, contractAddress string, privateKey string) (*StorkContract, error) {
	config := Config{
		RpcUrl:          rpcUrl,
		ContractAddress: contractAddress,
		PrivateKey:      privateKey,
	}

	configJSON, err := json.Marshal(config)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal fuel config: %w", err)
	}

	configCStr := C.CString(string(configJSON))

	//nolint:nlreturn // Defer is not a return statement
	defer C.free(unsafe.Pointer(configCStr))

	var outClient *C.FuelClient
	var outErrorPtr *C.char
	//nolint:gocritic,nlreturn // linters seemingly trip at some C calls..
	status := C.fuel_client_new(configCStr, &outClient, &outErrorPtr)

	err = handleFuelClientStatus(status)
	if err != nil {
		if outErrorPtr != nil {
			errorStr := C.GoString(outErrorPtr)
			C.fuel_free_string(outErrorPtr)

			return nil, fmt.Errorf("failed to create fuel client: %w: %s", err, errorStr)
		}

		return nil, fmt.Errorf("failed to create fuel client: %w", err)
	}

	if outClient == nil {
		return nil, ErrNullClientOnCreation
	}

	return &StorkContract{
		Client: outClient,
		Config: config,
	}, nil
}

// Helper function to convert C status codes to Go errors
//
//nolint:cyclop // Cyclomatic complexity is fine as this is a one level switch statement
func handleFuelClientStatus(status C.enum_FuelClientStatus) error {
	switch status {
	case C.Success:
		return nil
	case C.InvalidConfig:
		return ErrInvalidConfig
	case C.ContractCallFailed:
		return ErrContractCallFailed
	case C.NetworkError:
		return ErrNetworkError
	case C.InvalidTransactionParameters:
		return ErrInvalidTransactionParameters
	case C.JsonError:
		return ErrJSONError
	case C.SystemError:
		return ErrSystemError
	case C.WalletBalanceError:
		return ErrWalletBalanceError
	case C.NullPointer:
		return ErrNullPointer
	case C.IncorrectFeeAsset:
		return ErrIncorrectFeeAsset
	case C.InsufficientFee:
		return ErrInsufficientFee
	case C.NoFreshUpdate:
		return ErrNoFreshUpdate
	case C.FeedNotFound:
		return ErrFeedNotFound
	case C.InvalidSignature:
		return ErrInvalidSignature
	default:
		return fmt.Errorf("%w: %d", ErrUnknownError, int(status))
	}
}

func (s *StorkContract) UpdateTemporalNumericValuesV1(inputs []TemporalNumericValueInput) (string, error) {
	inputsJSON, err := json.Marshal(inputs)
	if err != nil {
		return "", fmt.Errorf("failed to marshal fuel inputs: %w", err)
	}

	inputsCStr := C.CString(string(inputsJSON))

	//nolint:nlreturn // Defer is not a return statement
	defer C.free(unsafe.Pointer(inputsCStr))

	var outTxHashPtr *C.char
	var outErrorPtr *C.char
	//nolint:gocritic,nlreturn // linters seemingly trip at some C calls..
	status := C.fuel_update_values(s.Client, inputsCStr, &outTxHashPtr, &outErrorPtr)

	err = handleFuelClientStatus(status)
	if err != nil {
		if outErrorPtr != nil {
			errorStr := C.GoString(outErrorPtr)
			C.fuel_free_string(outErrorPtr)

			return "", fmt.Errorf("failed to update values: %w: %s", err, errorStr)
		}

		return "", fmt.Errorf("failed to update values: %w", err)
	}

	if outTxHashPtr == nil {
		return "", ErrNullTransactionHash
	}

	txHash := C.GoString(outTxHashPtr)
	C.fuel_free_string(outTxHashPtr)

	return txHash, nil
}

func (s *StorkContract) GetTemporalNumericValueUncheckedV1(id [32]byte) (*TemporalNumericValue, error) {
	// Convert [32]byte to *C.uint8_t
	idPtr := (*[32]C.uint8_t)(unsafe.Pointer(&id))

	var outValueJSONPtr *C.char
	var outErrorPtr *C.char
	//nolint:gocritic,nlreturn // linters seemingly trip at some C calls..
	status := C.fuel_get_latest_value(s.Client, idPtr, &outValueJSONPtr, &outErrorPtr)

	err := handleFuelClientStatus(status)
	if err != nil {
		if outErrorPtr != nil {
			errorStr := C.GoString(outErrorPtr)
			C.fuel_free_string(outErrorPtr)

			return nil, fmt.Errorf("failed to get latest value: %w: %s", err, errorStr)
		}

		return nil, fmt.Errorf("failed to get latest value: %w", err)
	}

	valueJSON := C.GoString(outValueJSONPtr)
	C.fuel_free_string(outValueJSONPtr)

	var result TemporalNumericValue
	err = json.Unmarshal([]byte(valueJSON), &result)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal value JSON: %w", err)
	}

	return &result, nil
}

func (s *StorkContract) GetWalletBalance() (uint64, error) {
	var balance C.uint64_t
	var outErrorPtr *C.char
	//nolint:gocritic,nlreturn // linters seemingly trip at some C calls.
	status := C.fuel_get_wallet_balance(s.Client, &balance, &outErrorPtr)

	err := handleFuelClientStatus(status)
	if err != nil {
		if outErrorPtr != nil {
			errorStr := C.GoString(outErrorPtr)
			C.fuel_free_string(outErrorPtr)

			return 0, fmt.Errorf("failed to get wallet balance: %w: %s", err, errorStr)
		}

		return 0, fmt.Errorf("failed to get wallet balance: %w", err)
	}

	return uint64(balance), nil
}

func (s *StorkContract) Close() {
	if s.Client != nil {
		C.fuel_client_free(s.Client)
		s.Client = nil
	}
}
