package fuel

// the header file is generated by cbindgen. If you can't find it, run 'cargo build' in the fuel_ffi directory

/*
#cgo LDFLAGS: -L../../../../../.lib -lfuel_ffi
#cgo CFLAGS: -I../../../../../.lib
#include "fuel_ffi.h"
#include <stdlib.h>
#include <stdint.h>
*/
import "C"
import (
	"encoding/json"
	"fmt"
	"math/big"
	"unsafe"
)

type StorkContract struct {
	Client *C.FuelClient
	Config FuelConfig
}

type FuelConfig struct {
	RpcUrl          string `json:"rpc_url"`
	ContractAddress string `json:"contract_address"`
	PrivateKey      string `json:"private_key"`
}

type FuelTemporalNumericValue struct {
	TimestampNs    uint64   `json:"timestamp_ns"`
	QuantizedValue *big.Int `json:"quantized_value"`
}

type FuelTemporalNumericValueInput struct {
	TemporalNumericValue FuelTemporalNumericValue `json:"temporal_numeric_value"`
	Id                   string                   `json:"id"`
	PublisherMerkleRoot  string                   `json:"publisher_merkle_root"`
	ValueComputeAlgHash  string                   `json:"value_compute_alg_hash"`
	R                    string                   `json:"r"`
	S                    string                   `json:"s"`
	V                    uint8                    `json:"v"`
}

func NewStorkContract(rpcUrl string, contractAddress string, privateKey string) (*StorkContract, error) {
	config := FuelConfig{
		RpcUrl:          rpcUrl,
		ContractAddress: contractAddress,
		PrivateKey:      privateKey,
	}

	configJson, err := json.Marshal(config)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal fuel config: %w", err)
	}

	configCStr := C.CString(string(configJson))
	defer C.free(unsafe.Pointer(configCStr))

	var outClient *C.FuelClient
	var outErrorPtr *C.char
	status := C.fuel_client_new(configCStr, &outClient, &outErrorPtr)

	if err := handleFuelClientStatus(status); err != nil {
		if outErrorPtr != nil {
			errorStr := C.GoString(outErrorPtr)
			C.fuel_free_string(outErrorPtr)
			return nil, fmt.Errorf("failed to create fuel client: %w: %s", err, errorStr)
		}
		return nil, fmt.Errorf("failed to create fuel client: %w", err)
	}

	if outClient == nil {
		return nil, fmt.Errorf("fuel client creation returned null client")
	}

	return &StorkContract{
		Client: outClient,
		Config: config,
	}, nil
}

// Helper function to convert C status codes to Go errors
func handleFuelClientStatus(status C.enum_FuelClientStatus) error {
	switch status {
	case C.Success:
		return nil
	case C.InvalidConfig:
		return fmt.Errorf("invalid config")
	case C.ContractCallFailed:
		return fmt.Errorf("contract call failed")
	case C.NetworkError:
		return fmt.Errorf("network error")
	case C.InvalidTransactionParameters:
		return fmt.Errorf("invalid transaction parameters")
	case C.JsonError:
		return fmt.Errorf("JSON error")
	case C.SystemError:
		return fmt.Errorf("system error")
	case C.WalletBalanceError:
		return fmt.Errorf("wallet balance error")
	case C.NullPointer:
		return fmt.Errorf("null pointer")
	case C.IncorrectFeeAsset:
		return fmt.Errorf("incorrect fee asset")
	case C.InsufficientFee:
		return fmt.Errorf("insufficient fee")
	case C.NoFreshUpdate:
		return fmt.Errorf("no fresh update")
	case C.FeedNotFound:
		return fmt.Errorf("feed not found")
	case C.InvalidSignature:
		return fmt.Errorf("invalid signature")
	default:
		return fmt.Errorf("unknown error code: %d", int(status))
	}
}

func (s *StorkContract) UpdateTemporalNumericValuesV1(inputs []FuelTemporalNumericValueInput) (string, error) {
	inputsJson, err := json.Marshal(inputs)
	if err != nil {
		return "", fmt.Errorf("failed to marshal fuel inputs: %w", err)
	}

	inputsCStr := C.CString(string(inputsJson))
	defer C.free(unsafe.Pointer(inputsCStr))

	var outTxHashPtr *C.char
	var outErrorPtr *C.char
	status := C.fuel_update_values(s.Client, inputsCStr, &outTxHashPtr, &outErrorPtr)

	if err := handleFuelClientStatus(status); err != nil {
		if outErrorPtr != nil {
			errorStr := C.GoString(outErrorPtr)
			C.fuel_free_string(outErrorPtr)
			return "", fmt.Errorf("failed to update values: %w: %s", err, errorStr)
		}
		return "", fmt.Errorf("failed to update values: %w", err)
	}

	if outTxHashPtr == nil {
		return "", fmt.Errorf("received null transaction hash")
	}

	txHash := C.GoString(outTxHashPtr)
	C.fuel_free_string(outTxHashPtr)

	return txHash, nil
}

func (s *StorkContract) GetTemporalNumericValueUncheckedV1(id [32]byte) (*FuelTemporalNumericValue, error) {
	// Convert [32]byte to *C.uint8_t
	idPtr := (*C.uint8_t)(unsafe.Pointer(&id[0]))

	var outValueJsonPtr *C.char
	var outErrorPtr *C.char
	status := C.fuel_get_latest_value(s.Client, idPtr, &outValueJsonPtr, &outErrorPtr)

	if err := handleFuelClientStatus(status); err != nil {
		if outErrorPtr != nil {
			errorStr := C.GoString(outErrorPtr)
			C.fuel_free_string(outErrorPtr)
			return nil, fmt.Errorf("failed to get latest value: %w: %s", err, errorStr)
		}
		return nil, fmt.Errorf("failed to get latest value: %w", err)
	}

	valueJson := C.GoString(outValueJsonPtr)
	C.fuel_free_string(outValueJsonPtr)

	var result FuelTemporalNumericValue
	err := json.Unmarshal([]byte(valueJson), &result)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal value JSON: %w", err)
	}

	return &result, nil
}

func (s *StorkContract) GetWalletBalance() (uint64, error) {
	var balance C.uint64_t
	var outErrorPtr *C.char
	status := C.fuel_get_wallet_balance(s.Client, &balance, &outErrorPtr)

	if err := handleFuelClientStatus(status); err != nil {
		if outErrorPtr != nil {
			errorStr := C.GoString(outErrorPtr)
			C.fuel_free_string(outErrorPtr)
			return 0, fmt.Errorf("failed to get wallet balance: %w: %s", err, errorStr)
		}
		return 0, fmt.Errorf("failed to get wallet balance: %w", err)
	}

	return uint64(balance), nil
}

func (s *StorkContract) Close() {
	if s.Client != nil {
		C.fuel_client_free(s.Client)
		s.Client = nil
	}
}
