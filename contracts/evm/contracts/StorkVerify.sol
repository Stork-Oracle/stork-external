// SPDX-License-Identifier: UNLICENSED

pragma solidity >=0.8.24 <0.9.0;

contract StorkVerify {
    function getEthSignedMessageHash32(
        bytes32 message
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked("\x19Ethereum Signed Message:\n32", message)
            );
    }

    function getStorkMessageHashV1(
        address storkPubKey,
        bytes32 id,
        uint256 recvTime,
        int256 quantizedValue,
        bytes32 publisherMerkleRoot,
        bytes32 valueComputeAlgHash
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    storkPubKey,
                    id,
                    recvTime,
                    quantizedValue,
                    publisherMerkleRoot,
                    valueComputeAlgHash
                )
            );
    }

    function getPublisherMessageHash(
        address oracleName,
        string memory assetPairId,
        uint256 timestamp,
        uint256 value
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(oracleName, assetPairId, timestamp, value)
            );
    }

    function getSigner(
        bytes32 signedMessageHash,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) private pure returns (address) {
        return ecrecover(signedMessageHash, v, r, s);
    }

    function computeMerkleRoot(bytes32[] memory leaves) private pure returns (bytes32) {
        require(leaves.length > 0, "No leaves provided");

        while (leaves.length > 1) {
            if (leaves.length % 2 != 0) {
                // If odd number of leaves, duplicate the last one
                bytes32[] memory extendedLeaves = new bytes32[](leaves.length + 1);
                for (uint i = 0; i < leaves.length; i++) {
                    extendedLeaves[i] = leaves[i];
                }
                extendedLeaves[leaves.length] = leaves[leaves.length - 1];
                leaves = extendedLeaves;
            }

            bytes32[] memory nextLevel = new bytes32[](leaves.length / 2);
            for (uint i = 0; i < leaves.length; i += 2) {
                nextLevel[i / 2] = keccak256(abi.encodePacked(leaves[i], leaves[i + 1]));
            }
            leaves = nextLevel;
        }

        return leaves[0];
    }

    function verifyMerkleRoot(bytes32[] memory leaves, bytes32 root) public pure returns (bool) {
        return computeMerkleRoot(leaves) == root;
    }

    function verifyPublisherSignatureV1(
        address oraclePubKey,
        string memory assetPairId,
        uint256 timestamp,
        uint256 value,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) public pure returns (bool) {
        bytes32 msgHash = getPublisherMessageHash(
            oraclePubKey,
            assetPairId,
            timestamp,
            value
        );
        bytes32 signedMessageHash = getEthSignedMessageHash32(msgHash);

        // Verify hash was generated by the actual user
        address signer = getSigner(signedMessageHash, r, s, v);
        return (signer == oraclePubKey) ? true : false;
    }

    function verifyStorkSignatureV1(
        address storkPubKey,
        bytes32 id,
        uint256 recvTime,
        int256 quantizedValue,
        bytes32 publisherMerkleRoot,
        bytes32 valueComputeAlgHash,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) public pure returns (bool) {
        bytes32 msgHash = getStorkMessageHashV1(
            storkPubKey,
            id,
            recvTime,
            quantizedValue,
            publisherMerkleRoot,
            valueComputeAlgHash
        );

        bytes32 signedMessageHash = getEthSignedMessageHash32(msgHash);

        // Verify hash was generated by the actual user
        address signer = getSigner(signedMessageHash, r, s, v);
        return (signer == storkPubKey) ? true : false;
    }
}
