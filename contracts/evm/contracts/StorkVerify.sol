// SPDX-License-Identifier: UNLICENSED

pragma solidity >=0.8.24 <0.9.0;

contract StorkVerify {
    function getEthSignedMessageHash32(
        bytes32 message
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked("\x19Ethereum Signed Message:\n32", message)
            );
    }

    function getStorkMessageHashV1(
        address stork_pubkey,
        bytes32 id,
        uint256 recv_time,
        int256 quantizedValue,
        bytes32 publisherMerkleRoot,
        bytes32 valueComputeAlgHash
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    stork_pubkey,
                    id,
                    recv_time,
                    quantizedValue,
                    publisherMerkleRoot,
                    valueComputeAlgHash
                )
            );
    }

    function getPublisherMessageHash(
        address oracle_name,
        string memory asset_pair_id,
        uint256 timestamp,
        uint256 value
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(oracle_name, asset_pair_id, timestamp, value)
            );
    }

    function getSigner(
        bytes32 signed_message_hash,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) private pure returns (address) {
        return ecrecover(signed_message_hash, v, r, s);
    }

    function verifyPublisherSignatureV1(
        address oracle_pubkey,
        string memory asset_pair_id,
        uint256 timestamp,
        uint256 value,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) public pure returns (bool) {
        bytes32 msg_hash = getPublisherMessageHash(
            oracle_pubkey,
            asset_pair_id,
            timestamp,
            value
        );
        bytes32 signed_message_hash = getEthSignedMessageHash32(msg_hash);

        // Verify hash was generated by the actual user
        address signer = getSigner(signed_message_hash, r, s, v);
        return (signer == oracle_pubkey) ? true : false;
    }

    function verifyStorkSignatureV1(
        address stork_pubkey,
        bytes32 id,
        uint256 recv_time,
        int256 quantizedValue,
        bytes32 publisherMerkleRoot,
        bytes32 valueComputeAlgHash,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) public pure returns (bool) {
        bytes32 msg_hash = getStorkMessageHashV1(
            stork_pubkey,
            id,
            recv_time,
            quantizedValue,
            publisherMerkleRoot,
            valueComputeAlgHash
        );

        bytes32 signed_message_hash = getEthSignedMessageHash32(msg_hash);

        // Verify hash was generated by the actual user
        address signer = getSigner(signed_message_hash, r, s, v);
        return (signer == stork_pubkey) ? true : false;
    }
}
